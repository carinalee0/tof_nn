'''
This is an edited version of Amanda's run_simion.py.
I removed the group 'data1' and the functions for lognormal distributions.


'''
# -*- coding: utf-8 -*-
import subprocess
import os
import argparse
import re
import h5py
import matplotlib.pyplot as plt
import csv
import sys
sys.path.insert(0, os.path.abspath('..'))
from voltage_generator import calculateVoltage_NelderMeade
import time
import numpy as np
import pandas as pd

# Original
def check_h5_original(file):
    if file.endswith("h5"):
        with h5py.File(file, 'r') as f:
            x_tof = f['data1']['x'][:]
            y_tof = f['data1']['y'][:]
            tof_values = f['data1']['tof'][:]
            initial_ke = f['data1']['initial_ke'][:]
            elevation = f['data1']['elevation'][:]
            #print(initial_ke)

# My edit: removing the group 'data1'  
def check_h5(file):
    if file.endswith('h5'):
        with h5py.File(file, 'r') as f:
            x_tof = f['x'][:]
            y_tof = f['y'][:]
            tof_values = f['tof'][:]
            initial_ke = f['initial_ke'][:]
            elevation = f['elevation'][:]

def generate_files(data, output_dir):
    output_file, ext = os.path.splitext(output_dir)
    output_file = output_file + ".h5"
    with h5py.File(output_file, "w") as f:
        #g1 = f.create_group("data1") 
        for key, values in data.items():
            f.create_dataset(key, data=values)
        print("Data exported to:", output_dir)

def float_match(match):
    if 'R' in match:
        match = match.replace('R','')
    
    valueMatch = float(match.replace('neg','-').replace('pos','').replace('_',''))
    return valueMatch 

def getVoltages(fileName):
    fileName = str(fileName)
    retardationPattern=r"(?<=sim_)([^_]+_[^_]+)"
    retardationMatch=re.findall(retardationPattern, fileName) 
    mid1Pattern=r'^sim_[^_]+_[^_]+_([^_]+_[^_]+)_(?=[^_]+_[^_]+_)'
    mid1Match=re.findall(mid1Pattern, fileName)
    mid2Pattern=r"^sim_[^_]+_[^_]+_[^_]+_[^_]+_([^_]+_[^_]+)_(?=[^_])"
    mid2Match=re.findall(mid2Pattern, fileName)
    #kePattern=r"[^_]+_[^_]+_([^_]+)(?=.h5)"
    #keMatch=re.findall(keMatch, fileName)
    
    retardationValue = float_match(retardationMatch[0])
    mid1Value=float_match(mid1Match[0])
    mid2Value=float_match(mid2Match[0])
    #keValue=float_match(keMatch, fileName)
    
    return retardationValue, mid1Value, mid2Value

def parse_and_process_data(input_file_path):
    with open(input_file_path, 'r') as file:
        # The input file path is generated by f"sim_{rsign}_R{r}_{m1sign}_{mid1}_{m2sign}_{mid2}_{ke_fwhm}_n{numParticles}.txt"
        reader = csv.reader(file)
        next(reader)  # Skip the header line if there is one, or adjust if data starts immediately

        data = {
            "ion_number": [], "initial_azimuth": [], "initial_elevation": [], "initial_ke": [],
            "tof": [], "x": [], "y": [], "z": [], "final_azimuth": [], "final_elevation": [], "final_ke": [],
            'v_retardation':[], 'mid1_ratio':[], 'mid2_ratio':[]
        }

        for start_line in reader:
            if not start_line:
                continue
            splat_line = next(reader, None)  # Read the subsequent line for 'splat' data

            # Start line processing (initial conditions)
            data["ion_number"].append(int(start_line[0]))
            data["initial_azimuth"].append(float(start_line[8]))
            data["initial_elevation"].append(float(start_line[9]))
            data["initial_ke"].append(float(start_line[10]))

            # Splat line processing (final conditions)
            if splat_line:
                data["tof"].append(float(splat_line[2]))
                data["x"].append(float(splat_line[5]))
                data["y"].append(float(splat_line[6]))
                data["z"].append(float(splat_line[7]))
                data["final_azimuth"].append(float(splat_line[8]))
                data["final_elevation"].append(float(splat_line[9]))
                data["final_ke"].append(float(splat_line[10]))
                
        # Adding voltages as keys
        retardationValue, mid1Value, mid2Value = getVoltages(input_file_path)
        data['v_retardation'].append(retardationValue)
        data['mid1_ratio'].append(mid1Value)
        data['mid2_ratio'].append(mid2Value) 

        generate_files(data, input_file_path)

# Changed version by Carina  
# One-hot encoding the Event column so that the dataframe is all numeric
event_dict = {
    "Ion Created" : 1,
    "Crossed Y = 0 Plane" : 2,
    "Hit Electrode" : 3,
    "Outside Work Bench" : 4
    }

def digit_check(str):
    if '-' in str:
        str = str.replace('-','')
        
    if '.' in str:
        str = str.replace('.','')
    
    if 'e' in str:
        str = str.replace('e','')

    return str.isdigit()

# Parses result file and formats into a dataframe
def parse_results(results_file_path):
    with open(results_file_path, 'r') as file:
         results_lines = file.readlines()
    
         flym_counter = 0
         start_parse = False
         data_dict = {}
         data_list = []
         datasets_list = []

         for row in results_lines:  
        
            if "Begin Fly'm" in row: # Begin Fly'm occurs for each simulation
             flym_counter +=1
                
            if 'Ion(' in row:
                start_parse = True
            if data_dict: # If the dictionary is not empty, dump it into the list
                data_list.append(data_dict)
                data_dict = {} # Reinitialize dictionary
            if start_parse:
                matches = re.findall('(.*?)\\((.*?)\\)', row) # Regex match
                key = []
                value = []
                for match in matches:
                    key = match[0].strip()
                    value = match[1].strip()
                    
                    value_list = value.split(' ') # split value by space
                
                if len(value_list) >= 2 and digit_check(value_list[0]):
                    value = float(value_list[0])
                    unit = value_list[1]
                    key = f'{key}_{unit}' 

                value = value if key != "Event" else event_dict[value] # change Event to numeric value
                data_dict[key] = float(value)
         else:
            start_parse = False 
         
        # In case multiple simulations are appended to one results file, a list of datasets are created
         if flym_counter >= 0:
            datasets_list.append(data_list)
            data_list = []
                
    #print(data_list)
    # Will typically be a list of one (one simulation at a time)
    df_list = []
    for dataset in datasets_list:
        df = pd.DataFrame(dataset)
        df['Dataset_name'] = float(flym_counter)     
        df_list.append(df)

    return df_list

def fastAdj(voltageArray, potArrayFile):
    # pa0 file directory
    potArrLoc = potArrayFile
    # initialize string that will be supplied as argument of voltage values
    voltArgString = str()
    # convert supplied potential voltages into a string
    for i in range(voltageArray.size):
        # setup values for electrode number and voltage
        electrodeNumber = i + 1
        voltage = voltageArray[i]
        if((i+1) == voltageArray.size):
            stringToAdd = str(electrodeNumber) + "=" + str(voltage)
        else:
            stringToAdd = str(electrodeNumber) + "=" + str(voltage) + ","
        # add current electrode's parameters to string
        voltArgString = voltArgString + stringToAdd

    # go to simion's working directory and call simion
    subprocess.run("simion.exe --nogui fastadj " + potArrLoc + " " + voltArgString)

def fly(sim_cmd, fly_file, out_file, rec_file, bench):
    '''
    Fly n_parts particles using the particle probability distributions defined in self.parts.
    Parallelizes the fly processes by spawing a number of instances associated with the
    number of cores of the processing computer. Resulting particle data is stored in
    self.data as a simPyon.data.sim_data object.

    Parameters
    ----------
    n_parts: int
        number of particles to be flown. n_parts/cores number of particles is flown in each
        instance of simion on each core.
    cores: int
        number of cores to use to process the fly particles request. Default initializes
        a simion instance to run on each core.
    surpress_output: bool
        With surpress_output == True, the preparation statement from one of the simion
        instances is printed to cmd.
    '''

    start_time = time.time()

    # Fly the particles in parallel and scrape the resulting data from the shell
    loc_com = r"fly  "
    loc_com += r" --recording-output=" + out_file
    loc_com += r" --recording=" + rec_file
    loc_com += r" --particles=" + fly_file
    loc_com += r" -- restore-potentials=0 " + bench
    commands = loc_com
    subprocess.run(sim_cmd + ' ' + commands)
    print(time.time() - start_time)

# helper method that makes the call to run simion to fly particles.  This method links up all the required file
# directories into a single call to simion, which will then fly the simulation and create an outputFile
# fly2FileDir contains the definition of the particles that should be simulated.
# This file is made with the method 'makeFLY2File()'
# outputFile is the directory to which the output log will be saved.  This log is a summary of the simulation
# results, and is made by simion as simion runs the simulation
# recordingFile is a special file that has the recording options.  This is a file that can only be made in simion -
# it is a binary file that has a bunch of flags to tell the program what to record during simulation.
# the iobFileLoc is directory to the .IOB file, which is the ion bench file.  I am not fully sure that I understand what
# this is, but I think it is a file that links the potential arrays to the simulation.
def runSimion(fly2File, voltage_array, outputFile, recordingFile, iobFileLoc, potArrLoc, baseDir):
    # Check if outputFile exists and delete it if it does
    if os.path.isfile(outputFile):
        os.remove(outputFile)
    print("flying!")

    # Change to the SIMION working directory
    original_cwd = os.getcwd()
    print(original_cwd)
    os.chdir(r"C:\\Program Files\\SIMION-8.1")

    # Convert voltage_array to a space-separated string
    #voltage_string = ' '.join(map(str, voltage_array))
    fastAdj(voltage_array, potArrLoc)

    flyCommand = f"fly --recording-output=\"{outputFile}\" --recording=\"{recordingFile}\" " \
                 f"--particles=\"{fly2File}\" --restore-potentials=0 \"{iobFileLoc}\""

    # Construct the full command
    fullCommand = f"simion.exe --nogui {flyCommand}"
    # Go back to the base directory and delete temporary files
    print("starting flym")
    subprocess.run(fullCommand, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    print("finished flym")
    os.chdir(baseDir)
    os.system('del *.tmp')
    os.chdir(original_cwd)


if __name__ == '__main__':
    def dir_path(string):
        if os.path.isdir(string):
            return string
        else:
            raise argparse.ArgumentTypeError(f"readable_dir:{string} is not a valid path")

    baseDir = r"C:\\Users\\carina\\simion_files\\TOF_ML\\simulations\\TOF_simulation"
    iobFileLoc = baseDir + "/TOF_simulation.iob"
    recordingFile = baseDir + "/TOF_simulation.rec"
    potArrLoc = baseDir + "/copiedArray.PA0"
    lua_path = baseDir + "/TOF_simulation.lua"
    current_dir = os.path.dirname(os.path.realpath(__file__))

    parser = argparse.ArgumentParser(description='code for running LTSpice simulations')

    # Add arguments
    parser.add_argument('retardation', metavar='N', type=int, help='Required retardation value')
    parser.add_argument('simulation_dir', type=dir_path, help='Required simulation directory')
    parser.add_argument('--front_voltage', type=float, help='Optional front voltage value')
    parser.add_argument('--back_voltage', type=float, help='Optional back voltage value')

    args = parser.parse_args()
    print(args.front_voltage, args.back_voltage)

    Fly2File = args.simulation_dir + "\\TOF_simulation\\TOF_simulation.fly2"
    simion_output_path = args.simulation_dir + \
                         f"\\TOF_simulation\\simion_output\\test_R{args.retardation}.txt"

    cir_filepath = current_dir + "\\voltage_divider.cir"
    raw_file_path = args.simulation_dir + f"\\ltspice\\voltage_divider_R{args.retardation}.raw"

    ltspice_out_dir = args.simulation_dir + "\\ltspice"

    #generate_fly2File(Fly2File, numParticles=5000, minEnergy=args.retardation-100,
    #                  maxEnergy=args.retardation+1200)
    new_voltages, resistor_values = calculateVoltage_NelderMeade(args.retardation)
    #print(new_voltages)
    #new_cir_filepath = modify_cir_file(cir_filepath, new_voltages,
    #                                   args.simulation_dir + "\\ltspice", args.retardation)

    # Run the LTspice simulation
    #run_simulation(ltspice_path, new_cir_filepath, ltspice_out_dir)

    # Read the .raw file and check current values
    #ok, max_val = check_currents(raw_file_path)
    ok = True
    if ok:
        start = time.time()
        runSimion(Fly2File, new_voltages, simion_output_path, recordingFile, iobFileLoc, potArrLoc, baseDir)
        print(f"simion took: {time.time() - start}")
        parse_results(simion_output_path)
